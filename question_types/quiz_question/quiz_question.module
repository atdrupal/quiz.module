<?php

/**
 * Quiz Question module.
 * This module provides the basic facilities for adding quiz question types to a quiz.
 * @file
 */
/*
 * The system remembers what quizzes a user has been involved in lately. This constant determines
 * how many quizzes the system will remember for each user
 */
define('QUIZ_QUESTION_NUM_LATEST', 10);

/**
 * Include hook implementations.
 */
require_once dirname(__FILE__) . '/quiz_question.hooks.inc';

/**
 * Figure out if a user has access to score a certain result
 *
 * @param $vid
 *  Question version id
 * @param $result_id
 *  Result id
 * @return
 *  True if the user has access to score the result
 */
function quiz_question_access_to_score($vid, $result_id) {
  global $user;
  $sql = 'SELECT * FROM {quiz_node_results_answers} WHERE result_id = :result_id AND question_vid = :question_vid';
  $answer = db_query($sql, array(':result_id' => $result_id, ':question_vid' => $vid))->fetch();
  if (!$answer) {
    return FALSE;
  }
  if (user_access('score any quiz')) {
    return TRUE;
  }
  if (user_access('score taken quiz answer')) {
    $uid = db_query('SELECT uid from {quiz_node_results} qnr WHERE qnr.result_id = :result_id', array(':result_id' => $result_id))->fetchField();
    if ($uid == $user->uid) {
      return TRUE;
    }
  }
  if (user_access('score own quiz')) {
    return db_query('SELECT r.uid FROM {node_revision} r
            JOIN {quiz_node_results} qnr ON (r.nid = qnr.nid)
            WHERE qnr.result_id = :result_id
            ', array(':result_id' => $result_id))->fetchField() == $user->uid;
  }
}

/**
 * Get the form to show to the quiz taker.
 *
 * @param $nodes
 *   A list of question nodes to get answers from.
 * @param $result_id
 *   The result ID for this attempt.
 */
function quiz_question_answering_form($form, $form_state, $nodes, $result_id) {
  $quiz_result = quiz_result_load($result_id);

  if (!is_array($nodes)) {
    // One single question (or page?)
    if ($nodes->type == 'quiz_page') {
      foreach ($quiz_result->layout as $question) {
        if ($question['nid'] == $nodes->nid) {
          // Found a page
          $nodes = array(node_load($nodes->nid));
          foreach ($quiz_result->layout as $question2) {
            if ($question2['qnr_pid'] == $question['qnr_id']) {
              // This question belongs in the requested page.
              $nodes[] = node_load($question2['nid']);
            }
          }
          break;
        }
      }
    }
    else {
      $nodes = array($nodes->nid => $nodes);
    }
  }

  $form['#attributes']['class'] = array('answering-form');

  foreach ($nodes as $node) {
    $question = _quiz_question_get_instance($node);
    $class = drupal_html_class('quiz-question-' . $node->type);
    // Element for a single question
    $element = $question->getAnsweringForm($form_state, $result_id);
    $quiz = node_load(arg(1));

    // Hide the label of the body field if this is an informative question.
    $options = !$question->isGraded() ? array('label' => 'hidden') : array();

    node_build_content($node);
    unset($node->content['answers']);
    $form['questions'][$node->nid] = array(
      '#attributes' => array('class' => array($class)),
      '#type' => 'container',
      'header' => $node->content,
      'question' => array('#tree' => TRUE, $node->nid => $element),
    );

    if ($quiz->mark_doubtful) {
      $form['is_doubtful'] = array(
        '#type' => 'checkbox',
        '#title' => t('doubtful'),
        '#weight' => 1,
        '#prefix' => '<div class="mark-doubtful checkbox enabled"><div class="toggle"><div></div></div>',
        '#suffix' => '</div>',
        '#default_value' => 0,
        '#attached' => array(
          'js' => array(drupal_get_path('module', 'quiz') . '/theme/quiz_take.js'),
        ),
      );
      if (isset($node->result_id)) {
        $form['is_doubtful']['#default_value'] = db_query('SELECT is_doubtful FROM {quiz_node_results_answers} WHERE result_id = :result_id AND question_nid = :question_nid AND question_vid = :question_vid', array(':result_id' => $node->result_id, ':question_nid' => $node->nid, ':question_vid' => $node->vid))->fetchField();
      }
    }
  }

  $is_last = _quiz_show_finish_button($quiz);

  $form['navigation']['#type'] = 'actions';
  $form['navigation']['#theme'] = 'quiz_question_navigation_form';

  if (!empty($quiz->backwards_navigation) && (arg(3) != 1)) {
    // Backwards navigation enabled, and we are looking at not the first
    // question. @todo detect when on the first page.
    $form['navigation']['back'] = array(
      '#weight' => 10,
      '#type' => 'submit',
      '#value' => t('Back'),
      '#submit' => array('quiz_question_answering_form_submit_back'),
      '#limit_validation_errors' => array(),
    );
    if ($is_last) {
      $form['navigation']['#last'] = TRUE;
      $form['navigation']['last_text'] = array(
        '#weight' => 0,
        '#markup' => '<p><em>' . t('This is the last question. Press Finish to deliver your answers') . '</em></p>',
      );
    }
  }

  $form['navigation']['submit'] = array(
    '#weight' => 30,
    '#type' => 'submit',
    '#value' => $is_last ? t('Finish') : t('Next'),
  );

  if ($is_last && $quiz->backwards_navigation && !$quiz->repeat_until_correct) {
    // Display a confirmation dialogue if this is the last question and a user
    // is able to navigate backwards but not forced to answer correctly.
    $form['#attributes']['class'][] = 'quiz-answer-confirm';
    $form['#attributes']['data-confirm-message'] = t("By proceeding you won't be able to go back and edit your answers.");
    $form['#attached'] = array(
      'js' => array(drupal_get_path('module', 'quiz') . '/theme/quiz_confirm.js'),
    );
  }
  if ($quiz->allow_skipping) {
    $form['navigation']['skip'] = array(
      '#weight' => 20,
      '#type' => 'submit',
      '#value' => $is_last ? t('Leave blank and finish') : t('Leave blank'),
      '#access' => ($node->type == 'quiz_directions') ? FALSE : TRUE,
      '#submit' => $is_last ? array('quiz_question_answering_form_submit') : array('quiz_question_answering_form_submit_blank'),
      '#limit_validation_errors' => array(),
    );
  }

  return $form;
}

/**
 * Submit action for "leave blank".
 */
function quiz_question_answering_form_submit_blank($form, &$form_state) {
  $quiz = node_load(arg(1));
  $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  $quiz_result = quiz_result_load($result_id);
  $questions = $quiz_result->layout;
  foreach ($form_state['input']['question'] as $nid => $input) {
    // Loop over all question inputs provided, and record them as skipped.
    $question = node_load($nid);

    foreach ($questions as $question_item) {
      if ($question_item['nid'] == $question->nid) {
        $question_array = $question_item;
      }
    }

    $qi_instance = _quiz_question_response_get_instance($result_id, $question, NULL);
    $qi_instance->delete();
    $qi_instance->saveResult();
    $bare_object = $qi_instance->toBareObject();
    quiz_store_question_result($quiz, $bare_object, array('set_msg' => TRUE, 'question_data' => $question_array));
  }

  // Advance to next question.
  quiz_question_goto($quiz, $_SESSION['quiz'][$quiz->nid]['current'] + 1);
  $form_state['redirect'] = "node/{$quiz->nid}/take/" . $_SESSION['quiz'][$quiz->nid]['current'];
}

/**
 * Form for teaser display
 *
 * @param $node
 *  The question node
 * @return
 *  Content array
 */
function _quiz_question_teaser_content($node) {
  $content['question_type'] = array(
    '#markup' => '<div class="question_type_name">' . node_type_get_type($node)->name . '</div>',
    '#weight' => -100,
  );
  return $content;
}

/**
 * Update the session for this quiz to the active question.
 *
 * @param type $quiz
 *   A Quiz node.
 * @param type $question_number
 *   Question number starting at 1.
 */
function quiz_question_goto($quiz, $question_number) {
  $_SESSION['quiz'][$quiz->nid]['current'] = $question_number;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function quiz_question_has_been_answered($node) {
  $question_instance = _quiz_question_get_instance($node, true);
  return $question_instance->hasBeenAnswered();
}

/**
 * Get the configuration form for all enabled question types.
 */
function quiz_question_config($form, $context) {
  $q_types = _quiz_question_get_implementations();
  $form = array();
  $form['#validate'] = array();
  // Go through all question types and merge their config forms
  foreach ($q_types as $type => $values) {
    $function = $type . '_quiz_question_config';
    if ($admin_form = $function()) {
      $form[$type] = $admin_form;
      $form[$type]['#type'] = 'fieldset';
      $form[$type]['#title'] = $values['name'];
      $form[$type]['#collapsible'] = TRUE;
      $form[$type]['#collapsed'] = TRUE;
      if (isset($admin_form['#validate']) && is_array($admin_form['#validate'])) {
        $form['#validate'] = array_merge($form['#validate'], $admin_form['#validate']);
        unset($form[$type]['#validate']);
      }
    }
  }
  return system_settings_form($form);
}

/**
 * Get an instance of a quiz question.
 *
 * Get information about the class and use it to construct a new
 * object of the appropriate type.
 *
 * @param $node
 *  Question node
 * @param $use_cached
 *  Can we use a cached version of the node?
 * @return
 *  The appropriate QuizQuestion extension instance
 */
function _quiz_question_get_instance(&$node, $use_cached = FALSE) {
  // We use static caching to improve performance
  static $question_instances = array();

  $using_dummy_node = FALSE;
  if (is_object($node)) {
    $vid = isset($node->vid) ? $node->vid : 0;
    if ($use_cached && isset($question_instances[$vid])) {
      // We just return a cached instance of the QuizQuestion
      return $question_instances[$vid];
    }
    // If $node don't have a type it is a dummy node
    if (!isset($node->type)) {
      // To substanitally improve performance(especially on the result page) we avoid node_load()...
      // @todo why is this? consider getting rid of this as nodes are better
      // cached/retrieved in d7. adding the UID here to get rid of a notice.
      $sql = 'SELECT n.type, r.nid, r.vid, r.title, p.max_score, n.uid
              FROM {node_revision} r
              JOIN {node} n ON r.nid = n.nid
              JOIN {quiz_question_properties} p ON r.vid = p.vid
              WHERE r.vid = :vid';
      $node = db_query($sql, array(':vid' => $node->vid))->fetch();
      $using_dummy_node = TRUE;
    }
    $name = $node->type;
  }
  elseif (is_array($node)) {
    $name = $node['type'];
    $vid = $node['vid'];
    if ($use_cached && isset($question_instances[$vid])) {
      // We return a cached instance of the appropriate QuizQuestion
      return $question_instances[$vid];
    }
  }
  // No cached instance of QuizQuestion has been returned. We construct a new instance
  $info = _quiz_question_get_implementations();
  $constructor = $info[$name]['question provider'];
  if (empty($constructor)) {
    return FALSE;
  }

  // We create a new instance of QuizQuestion
  $to_return = new $constructor($node);
  if (!($to_return instanceof QuizQuestion)) {
    // Make sure the constructor is creating an extension of QuizQuestion
    drupal_set_message(t('The question-type %name isn\'t a QuizQuestion. It needs to extend the QuizQuestion class.', array('%name' => $name)), 'error', FALSE);
  }
  // If we're using a dummy node we have to run getNodeProperties, and populate the node with those properties
  if ($using_dummy_node) {
    $props = $to_return->getNodeProperties();
    foreach ($props as $key => $value) {
      $to_return->node->{$key} = $value;
    }
  }
  // Cache the node
  $question_instances[$vid] = $to_return;

  return $to_return;
}

/**
 * Get an instance of a quiz question responce.
 *
 * Get information about the class and use it to construct a new
 * object of the appropriate type.
 *
 * @param $result_id
 *  Result id
 * @param $question
 *  The question node(not a QuizQuestion instance)
 * @param $answer
 *  Resonce to the answering form.
 * @param $nid
 *  Question node id
 * @param $vid
 *  Question node version id
 * @return
 *  The appropriate QuizQuestionResponce extension instance
 */
function _quiz_question_response_get_instance($result_id, $question, $answer = NULL, $nid = NULL, $vid = NULL) {
  // We cache responses to improve performance
  static $quiz_responses = array();
  if (is_object($question) && isset($quiz_responses[$result_id][$question->vid])) {
    // We refresh the question node in case it has been changed since we cached the response
    $quiz_responses[$result_id][$question->vid]->refreshQuestionNode($question);
    if ($quiz_responses[$result_id][$question->vid]->is_skipped !== FALSE) {
      return $quiz_responses[$result_id][$question->vid];
    }
  }
  elseif (isset($quiz_responses[$result_id][$vid])) {
    if ($quiz_responses[$result_id][$vid]->is_skipped !== FALSE) {
      return $quiz_responses[$result_id][$vid];
    }
  }
  if (!isset($quiz_responses[$result_id])) {
    // Prepare to cache responses for this result id
    $quiz_responses[$result_id] = array();
  }
  // If the question node isn't set we fetch it from the QuizQuestion instance this responce belongs to
  if (!isset($question)) {
    $question_node = node_load($nid, $vid);
    $question = _quiz_question_get_instance($question_node, TRUE)->node;
  }
  if (!$question) {
    return FALSE;
  }
  $info = _quiz_question_get_implementations();
  $constructor = $info[$question->type]['response provider'];
  $to_return = new $constructor($result_id, $question, $answer);
  // All responce classes must extend QuizQuestionResponse
  if (!($to_return instanceof QuizQuestionResponse)) {
    drupal_set_message(t('The question-response isn\'t a QuizQuestionResponse. It needs to extend the QuizQuestionResponse interface, or extend the abstractQuizQuestionResponse class.'), 'error', FALSE);
  }
  // Cache the responce instance
  $quiz_responses[$result_id][$question->vid] = $to_return;

  return $to_return;
}

/**
 * Get the information about various implementations of quiz questions.
 *
 * @param $reset
 *  If this is true, the cache will be reset.
 * @return
 *  An array of information about quiz question implementations.
 * @see quiz_question_quiz_question_info() for an example of a quiz question info hook.
 */
function _quiz_question_get_implementations($name = NULL, $reset = FALSE) {
  static $info = array();
  if (empty($info) || $reset) {
    $qtypes = module_invoke_all('quiz_question_info');
    foreach ($qtypes as $type => $definition) {
      // We only want the ones with classes.
      if (!empty($definition['question provider'])) {
        // Cache the info
        $info[$type] = $definition;
      }
    }
    drupal_alter('quiz_question_info', $info);
  }
  return $info;
}

/**
 * Refreshes the quiz_question_latest_quizzes table when a user has modified a new quiz.
 *
 * The latest quizzes table is used to know what quizzes the user has been using lately.
 *
 * @param $nid
 *   nid of the last quiz the current user modified
 */
function quiz_question_refresh_latest_quizzes($nid) {
  global $user;
  // Delete entry if it allready exists
  db_delete('quiz_question_latest_quizzes')
    ->condition('uid', $user->uid)
    ->condition('quiz_nid', $nid)
    ->execute();

  // Inserts as new entry to get new id. Latest quizzes are ordered by id(descending)
  $id = db_insert('quiz_question_latest_quizzes')
    ->fields(array(
      'uid' => $user->uid,
      'quiz_nid' => $nid,
    ))
    ->execute();

  // If we have to many entries for current user, delete the oldest entries...
  $min_id = db_select('quiz_question_latest_quizzes', 'lq')
    ->fields('lq', array('id'))
    ->condition('uid', $user->uid)
    ->orderBy('id', 'DESC')
    ->range(QUIZ_QUESTION_NUM_LATEST - 1, 1)
    ->execute()
    ->fetchField();

  // Delete all table entries older than the nth row, if nth row was found.
  if ($min_id) {
    db_delete('quiz_question_latest_quizzes')
      ->condition('id', $min_id, '<')
      ->condition('uid', $user->uid)
      ->execute();
  }
}

/**
 * Removes a quiz from the quiz_question_latest_quizzes table.
 *
 * @param $nid
 *   the nid of a quiz that shall be removed
 */
function quiz_question_remove_latest_quizzes($nid) {
  db_delete('quiz_question_latest_quizzes')
    ->condition('quiz_nid', $nid)
    ->execute();
}

/**
 * Get the max score for a question
 *
 * @param $nid
 *  Question node id
 * @param $vid
 *  Question node version id
 * @return
 *  Max score(int)
 */
function quiz_question_get_max_score($nid, $vid) {
  return db_query('SELECT max_score
          FROM {quiz_question_properties}
          WHERE nid = :nid AND vid = :vid', array(':nid' => $nid, ':vid' => $vid))->fetchField();
}

/**
 * Returns a result report for a question response.
 *
 * The retaurned value is a form array because in some contexts the scores in the form
 * is editable
 *
 * @param $question
 *  The question node
 * @return
 *  FAPI form array
 */
function quiz_question_report_form($question) {
  $answer = $question->answers[0];
  $response_instance = _quiz_question_response_get_instance($answer['result_id'], $question, $answer);
  // If need to specify the score weight if it isn't already specified.
  if (!isset($response_instance->question->score_weight)) {
    $vid = db_query('SELECT vid FROM {quiz_node_results}
      WHERE result_id = :rid', array(':rid' => $answer['result_id']))
      ->fetchField();

    $qnr_max_score = db_query('SELECT qnr.max_score FROM {quiz_node_relationship} qnr
      WHERE qnr.child_vid = :child_vid AND qnr.parent_vid = :parent_vid', array(':child_vid' => $question->vid, ':parent_vid' => $vid))
      ->fetchField();

    if ($qnr_max_score === FALSE) {
      $qnr_max_score = db_query('SELECT qt.max_score FROM {quiz_node_results} qnr
         JOIN {quiz_node_results_answers} qnra ON (qnr.result_id = qnra.result_id)
         JOIN {quiz_terms} qt ON (qt.vid = qnr.vid AND qt.tid = qnra.tid)
         WHERE qnr.result_id = :rid AND qnra.question_nid = :qnid AND qnra.question_vid = :qvid', array(':rid' => $answer['result_id'], ':qnid' => $question->nid, ':qvid' => $question->vid))
        ->fetchField();
    }

    $response_instance->question->score_weight = ($qnr_max_score == 0 || $response_instance->question->max_score == 0) ? 0 : ($qnr_max_score / $response_instance->question->max_score);
  }

  return $response_instance->getReportForm();
}

/**
 * Add body field to quiz_question nodes.
 */
function quiz_question_add_body_field($type) {
  node_types_rebuild();
  $node_type = node_type_get_type($type);
  if (!$node_type) {
    watchdog('quiz', 'Attempt to add body field was failed as question content type %type is not defined.', array('%type' => $type), WATCHDOG_ERROR);
    watchdog('quiz', '<pre>' . print_r(node_type_get_types(), 1), array(), WATCHDOG_ERROR);
    return;
  }
  node_add_body_field($node_type, 'Question');
  // Override default weight to make body field appear first
  $instance = field_read_instance('node', 'body', $type);
  $instance['widget']['weight'] = -10;
  $instance['widget']['settings']['rows'] = 6;

  // Make the question body visible by default for the question view mode
  $instance['display']['question'] = array(
    'label' => 'hidden',
    'type' => 'text_default',
    'weight' => 1,
    'settings' => array(),
    'module' => 'text',
  );

  field_update_instance($instance);
}

/**
 * Return a form with question feedback.
 */
function quiz_question_feedback($quiz, $question) {

  if (empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
    $result_id = $_SESSION['quiz']['temp']['result_id'];
  }
  else {
    $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  }

  $types = _quiz_get_question_types();
  $module = $types[$question->type]['module'];
  // Invoke hook_get_report().
  $report = module_invoke($module, 'get_report', $question->nid, $question->vid, $result_id);
  $path = drupal_get_path('module', 'quiz');
  require_once DRUPAL_ROOT . '/' . $path . '/quiz.pages.inc';
  if ($report) {
    $report_form = drupal_get_form('quiz_report_form', array($report));
    return $report_form;
  }
}

/**
 * Submit handler for the question answering form.
 *
 * There is no validation code here, but there may be feedback code for
 * correct feedback.
 */
function quiz_question_answering_form_submit(&$form, &$form_state) {
  $quiz = node_load(arg(1));
  $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
  $questions = $quiz_result->layout;

  if (!empty($form_state['values']['question'])) {
    foreach ($form_state['values']['question'] as $nid => $answer) {
      $current_question = node_load($nid);
      foreach ($questions as $question) {
        if ($question['nid'] == $current_question->nid) {
          $question_array = $question;
        }
      }
      $qi_instance = _quiz_question_response_get_instance($_SESSION['quiz'][$quiz->nid]['result_id'], $current_question, $form_state['values']['question'][$current_question->nid]);
      $qi_instance->delete();
      $qi_instance->saveResult();
      $result = $qi_instance->toBareObject();
      quiz_store_question_result($quiz, $result, array('set_msg' => TRUE, 'question_data' => $question_array));

      // Increment the counter.
      quiz_question_goto($quiz, $_SESSION['quiz'][$quiz->nid]['current'] + 1);
    }
  }

  // Wat do?
  if (!empty($quiz->review_options['question']) && array_filter($quiz->review_options['question'])) {
    // We have question feedback.
    $form_state['redirect'] = "node/$quiz->nid/take/" . ($_SESSION['quiz'][$quiz->nid]['current'] - 1) . '/feedback';
  }
  else {
    // No question feedback. Go to next question.
    $form_state['redirect'] = "node/$quiz->nid/take/" . ($_SESSION['quiz'][$quiz->nid]['current']);
  }

  if (!isset($quiz_result->layout[$_SESSION['quiz'][$quiz->nid]['current']])) {
    // No more questions. Score quiz.
    $score = quiz_end_scoring($_SESSION['quiz'][$quiz->nid]['result_id']);

    // Delete old results if necessary.
    _quiz_maintain_results($quiz, $quiz_result->result_id);
    if (empty($quiz->review_options['question']) || !array_filter($quiz->review_options['question'])) {
      // Only redirect to question results if there is not question feedback.
      $form_state['redirect'] = "node/{$quiz->nid}/quiz-results/{$quiz_result->result_id}/view";
    }

    quiz_end_actions($quiz, $score, $_SESSION['quiz'][$quiz->nid]);

    // Remove all information about this quiz from the session.
    // @todo but for anon, we might have to keep some so they could access
    // results
    // When quiz is completed we need to make sure that even though the quiz has
    // been removed from the session, that the user can still access the
    // feedback for the last question, THEN go to the results page.
    $_SESSION['quiz']['temp']['result_id'] = $quiz_result->result_id;
    unset($_SESSION['quiz'][$quiz->nid]);
  }
}

/**
 * Submit handler for "back".
 */
function quiz_question_answering_form_submit_back(&$form, &$form_state) {
  // Back a question.
  $quiz = node_load(arg(1));
  quiz_question_goto($quiz, $_SESSION['quiz'][$quiz->nid]['current'] - 1);
  $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
  $question = $quiz_result->layout[$_SESSION['quiz'][$quiz->nid]['current']];
  if (!empty($question['qnr_pid'])) {
    foreach ($quiz_result->layout as $question2) {
      if ($question2['qnr_id'] == $question['qnr_pid']) {
        quiz_question_goto($quiz, $question2['number']);
      }
    }
  }

  $form_state['redirect'] = "node/$quiz->nid/take/" . ($_SESSION['quiz'][$quiz->nid]['current']);
}

/**
 * Validation callback for quiz question submit.
 */
function quiz_question_answering_form_validate(&$form, &$form_state) {
  $quiz = node_load(arg(1));
  foreach ($form_state['values']['question'] as $nid => $answer) {
    $current_question = node_load($nid);

    if ($current_question) {
      // There was an answer submitted.
      $quiz_question = _quiz_question_get_instance($current_question);
      $quiz_question->getAnsweringFormValidate($form, $form_state);
    }
  }
}

/**
 * Element validator (for repeat until correct).
 */
function quiz_question_element_validate(&$element, &$form_state) {
  $quiz = node_load(arg(1));
  $question_nid = $element['#array_parents'][1];
  $answer = $form_state['values']['question'][$question_nid];
  $current_question = node_load($question_nid);

  // There was an answer submitted.
  $result = _quiz_question_response_get_instance($_SESSION['quiz'][$quiz->nid]['result_id'], $current_question, $answer);
  if ($quiz->repeat_until_correct && !$result->isCorrect()) {
    form_set_error('', t('The answer was incorrect. Please try again.'));

    $feedback = quiz_question_feedback($quiz, $current_question);
    $element['feedback'] = array(
      '#weight' => 100,
      '#markup' => drupal_render($feedback),
    );
  }
}

/**
 * Theme the feedback for any question type.
 */
function theme_quiz_question_feedback($variables) {
  $rows = $variables['data'];
  $headers = array_intersect_key($variables['labels'], $rows[0]);

  return theme('table', array('header' => $headers, 'rows' => $rows));
}

/**
 * Helper function to faciliate icon display, like "correct" or "selected".
 */
function quiz_icon($icon) {
  return theme('quiz_answer_result', array('type' => $icon));
}
