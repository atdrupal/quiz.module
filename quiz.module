<?php

use Drupal\quiz\Entity\QuizEntityType;
use Drupal\quiz\Entity\Result;
use Drupal\quiz\Quiz;

/**
 * @file
 * Quiz Module
 *
 * This module allows the creation of interactive quizzes for site visitors.
 *
 * Where possible, user pages are located in quiz.pages.inc, and admin pages
 * are in quiz.admin.inc. Most utility functions have been left here, even if they
 * are only used by a function in one of the other files. quiz_datetime.inc holds
 * some additional date/time functions.
 *
 * Themes are in quiz.pages.inc unless they clearly only apply to admin screens.
 * Then they are in quiz.admin.inc.
 *
 * Views support is included in includes/views/quiz.views.inc
 *
 * Function starts with __quiz_ will be removed.
 */
define('QUIZ_VIEWS_DIR', drupal_get_path('module', 'quiz') . '/includes/views');

/**
 * Include hook implementations.
 */
require_once dirname(__FILE__) . '/quiz.hooks.inc';
require_once dirname(__FILE__) . '/quiz.take.inc';

/*
 * Define question statuses...
 */
define('QUESTION_RANDOM', 0);
define('QUESTION_ALWAYS', 1);
define('QUESTION_NEVER', 2);

/**
 * Quiz name.
 */
define('QUIZ_NAME', _quiz_get_quiz_name());

/**
 * Define options for keeping results.
 */
define('QUIZ_KEEP_BEST', 0);
define('QUIZ_KEEP_LATEST', 1);
define('QUIZ_KEEP_ALL', 2);

/**
 * Factory to create quiz helpers wrapper.
 *
 * @staticvar Quiz $quiz
 * @param string $className
 * @return \Drupal\quiz\Quiz
 */
function quiz($className = 'Drupal\quiz\Quiz') {
  static $quiz;
  return null === $quiz ? ($quiz = new $className) : $quiz;
}

/**
 * Gets an array of all quiz types, keyed by the type name.
 *
 * @return \Drupal\quiz\Entity\QuizEntityType[]
 */
function quiz_get_types() {
  return entity_load_multiple_by_name('quiz_type');
}

/**
 * Get quiz-type by machine name.
 *
 * @param string $name
 * @return \Drupal\quiz\Entity\QuizEntityType
 */
function quiz_type_load($name) {
  $type = entity_load_multiple_by_name('quiz_type', array($name));
  return isset($type[$name]) ? $type[$name] : null;
}

/**
 * Load quiz entity
 *
 * @return \Drupal\quiz\Entity\QuizEntity
 */
function quiz_entity_single_load($id = NULL, $vid = NULL) {
  if (NULL === $vid) {
    return entity_load_single('quiz_entity', $id);
  }

  $results = entity_load('quiz_entity', array(), array('vid' => $vid));
  if (!empty($results)) {
    return reset($results);
  }
}

/**
 * This function was copied from the triggers module as to prevent having to be
 * dependent on that module for the actions to work.  The trigger function is
 * called trigger_options().
 *
 * @param $type
 *   One of 'node', 'user', 'comment'.
 *
 * @return
 *   Array keyed by action ID.
 */
function quiz_action_options($type = 'all') {
  $options = array(t('Choose an action'));
  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {
    $options[$action['type']][$aid] = $action['label'];
  }

  if ($type == 'all') {
    return $options;
  }
  else {
    $options[$type][0] = t('Choose an action');
    // Lets sort it to get the choose an action back first.
    ksort($options[$type]);
    return $options[$type];
  }
}

/**
 * Returns an array with quiz titles keyed with quiz node ids.
 *
 * @return array
 *   Options suitable for a form, in which the value is nid.
 */
function quiz_get_quiz_options() {
  return quiz()->getQuizHelper()->getSettingHelper()->getQuizOptions();
}

/**
 * Finds out if a quiz has been answered or not.
 *
 * @return
 *   TRUE if there exists answers to the current question.
 */
function quiz_has_been_answered($quiz) {
  return quiz()->getQuizHelper()->isAnswered($quiz);
}

/**
 * Menu access check for question feedback.
 */
function quiz_question_feedback_access($quiz, $question_number) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canAccess($quiz, $question_number);
}

/**
 * Load a specific result answer.
 */
function quiz_result_answer_load($result_id, $question_nid, $question_vid) {
  return quiz()->getQuizHelper()->getResultHelper()->loadAnswerResult($result_id, $question_nid, $question_vid);
}

/**
 * Action to add questions to the current quiz.
 */
function quiz_add_question_to_quiz($question) {
  $quiz = 'node' === arg(0) ? node_load(arg(1)) : quiz_entity_single_load(arg(1));
  return quiz()->getQuizHelper()->addQuestion($quiz, $question);
}

/**
 * Can the quiz taker view the requested review?
 *
 * There's a workaround in here: @kludge
 *
 * When review for the question is enabled, and it is the last question,
 * technically it is the end of the quiz, and the "end of quiz" review settings
 * apply. So we check to make sure that we are in question taking and the
 * feedback is viewed within 5 seconds of completing the question/quiz.
 */
function quiz_feedback_can_review($option, $quiz_result) {
  return quiz()->getQuizHelper()->getFeedbackHelper()->canReview($option, $quiz_result);
}

/**
 * Updates the max_score property on the specified quizzes
 *
 * @param $vids
 *  Array with the vid's of the quizzes to update
 */
function quiz_update_max_score_properties($vids) {
  return quiz()->getQuizHelper()->updateMaxScoreProperties($vids);
}

/**
 * @param string $question_type
 *
 * @return string
 *   Name of module matching the question type, as given by quiz_question_info()
 *   hook.
 */
function quiz_question_module_for_type($question_type) {
  return quiz()->getQuizHelper()->getQuestionModuleFromType($question_type);
}

// ---------------------
//  Internal functions
// ---------------------

/**
 * Helper function used when validating integers.
 *
 * @param $value
 *   The value to be validated.
 * @param $min
 *   The minimum value $value is allowed to be.
 * @param $max
 *   The maximum value $value is allowed to be.
 *
 * @return
 *   TRUE if integer in the allowed range. FALSE otherwise.
 */
function _quiz_is_int($value, $min = 1, $max = NULL) {
  $to_return = ((string) $value === (string) (int) $value);

  // $value is not an integer.
  if (!$to_return) {
    return FALSE;
  }

  // $value is too small.
  if ($value < $min) {
    return FALSE;
  }

  // $value is too big.
  if (isset($max) && $value > $max) {
    return FALSE;
  }

  // $value is an integer in the allowed range.
  return TRUE;
}

/**
 * Retrieve list of question types.
 *
 * @return
 *  Array of question types.
 */
function _quiz_get_question_types() {
  static $quiz_questions = array();

  // We vastly improves performance by statically caching the question types.
  if (!empty($quiz_questions)) {
    return $quiz_questions;
  }

  // Get question types from the modules that defines them.
  if ($quiz_questions = module_invoke_all('quiz_question_info')) {
    return $quiz_questions;
  }

  drupal_set_message(t('You need to install and enable at least one question type(multichoice for instance) to use quiz.'), 'warning', FALSE);
  return array();
}

/**
 * Get the quiz name variable and set it as a constant so we don't have to keep
 * calling it in every function.
 *
 * @return
 *   Quiz name variable.
 */
function _quiz_get_quiz_name() {
  // @todo: remove all the quiz_name stuff? Isn't there better ways to do this?
  return variable_get('quiz_name', 'Quiz');
}

function __quiz_get_context_id() {
  return (int) arg(1);
}
